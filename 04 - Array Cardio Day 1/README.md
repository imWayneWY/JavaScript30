# day04 Array Cardio Day 1
18/6/3

## 1、 filter
筛选操作，filter(callback),filter中有一回调函数，若数组中某一项满足回调函数的条件，返回true，否则返回false；最后由返回true的项组成新的数组。

## 2、 map
映射操作，将数组中的每一个元素都经过callback函数处理后，返回新的元素，由这些新的元素组成新的数组。 这个方法适用于创建包含的项与另一个数组一一对应的数组。 

##3、 sort
比较操作，首先自定义比较函数，分别传入数组中前后两项，如果期望排序后第一个参数的值出现在第二个参数之前，则应返回负数。 

##4、 reduce
首先该方法只采用归并方法.reduce()，但其中回调函数的第一个参数的使用是很绝妙的，表示总年龄total，并将其初始化为0，（.reduce()方法的第二个参数为初始值），回调函数的第二个参数为数组中当前元素，用curr.passed-curr.year即可算出当前的年龄，再与total相加即为最终总年龄。

##5、 sort
同3

##6、 .forEach() & .filter()
这道题只要找到网页中节点中所对应的元素值，将其转化为数组，就方便很多了，就是在一个元素为字符串的数组中筛选出字符串中包含de的即可，采用字符串的.includes()方法即可实现，包含返回true，不包含返回false。 这里提醒一点，allStreet.filter()返回筛选后的数组后，会新建一个数组保存，此时如果我们console.log(allStreet);会仍然显示原数组，因为筛选出来的元素会被存在新数组中。 需要提一点，由 querySelectorAll() 获取到的是一个 NodeList ，它并非是 Array 类型的数据，所以并不具有 map 和 filter 这样的方法，所以如果要进行筛选操作则需要把它转化成 Array 类型，使用示例之中的 Array.from() 来转化即可。

##7、 String.prototype.split()
这里通过String.prototype.split()方法，将每一个用,分开的姓名分开，分别保存，再通过自定义排序函数即可完成按照姓氏顺序排序的任务。

##8、 reduce
这道题也是采用了.reduce()方法，回调函数的第一个参数也是精巧的地方，设置为一个对象，用来分别存储每一类的数量，第二个参数为当前的元素，如果obj[item]不存在，就将其值初始化为0，否则就将改值加1，最后返回该对象，即分别存储了各个类别的数量。

有一点需要注意的是，不要忘记给.reduce()方法的第二个参数设置初始值，因为改方法最终新建了一个自定义对象，因此，其初始值也应为一个空的对象。

##Tip
在Console面板下进行调试时，我们常用的是consol.log()，但console还有一个方法也十分好用，是console.table()，该方法会将待调试的内容以表格的形式打印出来，看上去十分明了。 但是，并不是什么时候都能用console.table()的，如果待显示内容不能够用表格的形式表示，就什么也不会输出，此时千万不要以为是没有输出结果，很有可能只是调试的方法错了，换一下console.log()兴许就会得到结果了。